项目简介：
正则解析器： regular_expr文件夹下，dfa实现：原生支持连接，或，星号等操作;进一步功能拓展可在StandardizeExpr实现;
    解析规则： . | * ( ) 为原生保留符号，存在控制逻辑的特殊意义。如若正则表达式中需要，需要\转义。\符号将会把后续的符号作为符号解析，举例如下：\. \| \* \\ \( \)
        在后续扩展（StandardizeExpr）中，存在 [ - ] \s等扩展，分别是范围操作与空格替换，可根据需要进行扩展
    使用举例： (a|bc)* 可以匹配如： aaa, abcbcaa等

词法分析器：基于正则解析，context_free下lexical_parser
    词法分析器接受参数：结构unordered_map     key, value: pair<string, int>(解析用正则， 优先级)
    使用举例： key: id, value: pair<string， int>("[0-9]*", 1); 当匹配到 [0-9]*（最长匹配规则）时，返回id。优先级1表示同时匹配住0,1两个优先级，返回优先级高的key
        解析字符串参数需要用Buffer结构承载 
    项目应用：表达式词法解析
         代码词法解析

上下文解析器： context_free文件下cf_xpr 与 cf_engine
    cf_expr：
        表达式词法：key, key reg expr, priority, is terminator（0：no, 1:yes）, nullable(0: no, 1:yes, 2:unkwon); 
            前三者为词法解析器必要信息，后两者为词法单元组成基本信息
        代码词法： key, key reg expr, priority； 词法解析器必要信息
        表达式文法： 
            第一非空行：非终结字符，解析开始符号
            辅助代码：%%***%%包括头文件包含，对象声明，归约动作所需的静态全局变量, 共用函数等;一般地，可以将辅助代码写入一个头文件进行包含
            表达式：_number_ 非终结字符 产生式主体（可以在特定位置插入_string_）;
                _number_: 正则解析得到数字，作为表达式编号
                非终结字符： 表达式的左侧
                产生式主体： 表达式的右侧
                _string_: 以{}为两端的可解析正则 具体可解析语义如下：
                    {reduction_priority=1} (归约优先级，当同时存在两个可以归约的表达式，以优先级高的表达式优先归约)
                    {reduction_first=symbol1, symbol2} （当可以归约也可以继续匹配时，该语句指示具体动作：当下一个符号在列表中，进行归约，否则继续匹配）
                    {reduction_action=func1($1, arg2);} （归约动作：支持c++语法,函数原型void(*)(CfInfo& pinfo, std::vector<CfInfo>& kinfos),
                        特殊地，可以用$0 $1表示第一与第二个参数，$-1~$-9表示knodes[kinfos.size() - i]元素值）
                    {action_1=func1($-1, arg2);} （非归约动作，在匹配住相应文法符号后进行，语义规则与归约动作规则一致）
                结束标志： ";" 
                约定： 语义动作支持c++语言({}的嵌套最大支持三层)，需要采用二次编译生效，即编译第一次并运行产生目标文件（debug/resolvable_file/aux_code.h），第二次编译，将目标文件编译生成代码
                定义语法规则遵循以下范式：对于全局语法，若不少于一类产生式存在迪卡尔乘积关系的语法，需要将其拆分，以减少语法规则的数量
                    
    cf_engine读取代码文件：
        分析运行相应动作，并生成分析树（给出一个全局信息，可根据需要进一步分析），目前词法与文法错误的处理为直接打印错误信息并结束,可以根据需要修改错误避让规则

机器无关代码优化：
    function:
        将指令对应的优化动作对应成函数，将函数关系理出，给出函数关系图。
        迭代法分析：
            整理函数拓扑关系，使得前继函数总是在后继函数（还存在跨边等关系）前被分析。按顺序迭代执行，直到每一个函数的输出不变
        区域分析： 相比迭代执行效率更高，循环处理仅在循环内函数间进行
            如前整理函数拓扑关系，找到循环，将循环作为子执行列表加入执行队列。顺序找出所有循环（存在子循环，加入到父循环内层）。对于循环，迭代执行，获取每一次循环返回入口的值，当迭代稳定，取交关系，
            得到最后执行循环的入口值，执行一次，给出循环各出口的值
