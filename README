项目简介：
正则解析器： regular_expr文件夹下，dfa实现：原生支持连接，或，星号等操作;进一步功能拓展可在StandardizeExpr实现;
使用举例： (a|bc)* 可以匹配如： aaa, abcbcaa等
拓展后支持： [] \s等

词法分析器：基于正则解析，context_free下lexical_parser。接受unordered_map作为参数：key: 解析key, value: pair<string, int>(解析用正则， 优先级)
    优先级决定同时匹配两种规则时，以优先级高的为标准;优先最长匹配
    应用：表达式词法解析（key, key reg expr, priority, is terminator, nullable，后两者为词法单元组成）
         代码词法解析（key, key reg expr, priority） 当key不存在对应表达式词法时，会被跳过，可以用于注释

上下文解析器： context_free文件下cf_xpr 与 cf_engine
    cf_expr中读取表达式词法规则与表达式：
        表达式词法：（key, key reg expr, priority, is terminator（0：no, 1:yes）, nullable(0: no, 1:yes, 2:unkwon)，前三者生成词法解析器，后两者为词法单元组成基本信息）
        表达式： 文件第一非空行：非终结字符解析开始位置
            辅助代码：%%***%%包括头文件包含，对象声明，归约动作所需的静态全局变量, 共用函数等;一般地，可以将辅助代码写入一个头文件进行包含
            后续文件：编号 非终结字符 产生式 "reduction_priority=1" "reduction_first=symbol1, symbol2" "reduction_action=func1($-1, arg2); func2()" ;
                约定： "reduction_action"中内容约定了归约动作, "reduction_first":表示该符号应该优先归约， "reduction_priority":归约表达式优先级
                    reduction_action被解析为以(CfTreeNode* pnode, std::vector<CfTreeNode*> knodes)为参数的动作函数，与辅助代码于同一文件下
                    knodes表示当前已知节点（统计到上一归约点及前兄弟节点，对于分析过程及时运行动作，无此限制）
                    $-1中数字表示偏移量，负号表示向前面已知节点偏移， $0表示父节点
                自定义动作支持c++语言。采用二次编译生效，即编译第一次并运行产生目标文件，第二次编译，将目标文件编译生成代码
    cf_engine读取代码文件：
        生成分析树，目前词法与文法错误的处理为直接打印错误信息并结束,可以根据需要修改错误避让规则

代码分析： 根据code_file中规则进行分析

