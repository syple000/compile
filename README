项目简介：
正则解析器： regular_expr文件夹下，dfa实现：原生支持连接，或，星号等操作;进一步功能拓展可在StandardizeExpr实现;
    解析规则： . | * ( ) 为原生保留符号，存在控制逻辑的特殊意义。如若正则表达式中需要，需要\转义。\符号将会把后续的符号作为符号解析，举例如下：\. \| \* \\ \( \)
        在后续扩展（StandardizeExpr）中，存在 [ - ] \s等扩展，分别是范围操作与空格替换，可根据需要进行扩展
    使用举例： (a|bc)* 可以匹配如： aaa, abcbcaa等

词法分析器：基于正则解析，context_free下lexical_parser
    词法分析器接受参数：结构unordered_map     key, value: pair<string, int>(解析用正则， 优先级)
    使用举例： key: id, value: pair<string， int>("[0-9]*", 1); 当匹配到 [0-9]*（最长匹配规则）时，返回id。优先级1表示同时匹配住0,1两个优先级，返回优先级高的key
        解析字符串参数需要用Buffer结构承载 
    项目应用：表达式词法解析
         代码词法解析

上下文解析器： context_free文件下cf_xpr 与 cf_engine
    cf_expr：
        表达式词法：key, key reg expr, priority, is terminator（0：no, 1:yes）, nullable(0: no, 1:yes, 2:unkwon); 
            前三者为词法解析器必要信息，后两者为词法单元组成基本信息
        代码词法： key, key reg expr, priority； 词法解析器必要信息
        表达式文法： 
            第一非空行：非终结字符，解析开始符号
            辅助代码：%%***%%包括头文件包含，对象声明，归约动作所需的静态全局变量, 共用函数等;一般地，可以将辅助代码写入一个头文件进行包含
            表达式：_number_ 非终结字符 产生式主体（可以在特定位置插入_string_）;
                _number_: 正则解析得到数字，作为表达式编号
                非终结字符： 表达式的左侧
                产生式主体： 表达式的右侧
                _string_: 以""为两端的可解析正则（内部" 以 \q表示）具体可解析语义如下：
                    "reduction_priority=1" (归约优先级，当同时存在两个可以归约的表达式，以优先级高的表达式优先归约)
                    "reduction_first=symbol1, symbol2" （当可以归约也可以继续匹配时，该语句指示具体动作：当下一个符号在列表中，进行归约，否则继续匹配）
                    "reduction_action=func1($1, arg2);" （归约动作：支持c++语法,函数原型void(*)(CfTreeNode* pnode, std::vector<CfTreeNode*> knodes),
                        特殊地，可以用$0 $1表示第一与第二个参数，$-1~$-9表示knodes[knodes.size() - i]元素值）
                    "action_1=func1($-1, arg2);" （非归约动作，在匹配住相应文法符号后进行，语义规则与归约动作规则一致）
                结束标志： ";" 
                约定： 语义动作支持c++语言，需要采用二次编译生效，即编译第一次并运行产生目标文件（debug/resolvable_file/aux_code.h），第二次编译，将目标文件编译生成代码
    cf_engine读取代码文件：
        分析运行相应动作，并生成分析树（给出一个全局信息，可根据需要进一步分析），目前词法与文法错误的处理为直接打印错误信息并结束,可以根据需要修改错误避让规则

集合比较改进：对于状态数不大的情况，可以使用位向量改进速度(本代码解析方面无此需求，生成状态表在第一次生成后可借助读取文件实现，无需反复生成，对速度不敏感)。
注：数据流分析代码在分析时运行，需依赖位向量改善效率