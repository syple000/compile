词法解析（lexical_parser）：对于某个字符缓存，若匹配某一个字符串，返回该串对应的键，
同时缓存位置前移
    基于正则解析实现：
        接受参数：结构unordered_map<string, pair<string, int>>
            key表示键值; value中pair第一个参数表示键值对应的的正则表达式，第二个参
            数表示匹配优先级（同时匹配，返回高优先级键）
    使用示例：key: id, value: pair<string， int>("[0-9]*", 1); 当匹配到 [0-9]
    *（最长匹配规则）时，返回id


上下文无关解析：对某一个代码文件，若匹配文法，则给出文法动作执行结果
    读取词法规则文件，文法规则文件，代码词法对应规则文件，生成状态转换表，初次运行后生成
    文法动作翻译文件（在aux_code目录下）

    词法规则文件：
        由条目列组成 
        条目：键, 正则式, 优先级, 是否终结符号（0：no, 1:yes）, 是否可空(0: no, 1:ye
        s, 2:unkwon) 
    
    文法规则文件：
        由非终结文法开始符号， 辅助代码， 具体文法列组成
        非终结文法开始符号： 第一非空行给出，表示文法状态表的第一符号
        
        辅助代码： 形如%% ** %% 其中**表示代码
            代码完全支持c++语法。在实践中，可将代码实现在单独文件中，include引入

        文法： 编号（数字），非终结字符，产生式主体，归约约定（可无），文法结束标志(为 ;)
            小约定：终结字符小写，非终结字符大写，形如_**_作保留符号
                语义动作由正则解析得到，支持c++语法，但{}仅支持三层嵌套
            
            产生式主体可内嵌语法动作：以{}为两端的可解析正则
                归约动作：{reduction_action=func1($1, arg2);} （支持c++语法,函数原型
                void(*)(CfInfo& pinfo, std::vector<CfInfo>& kinfos),特殊地，可以用
                $0 $1表示第一与第二个参数，$-1~$-9表示knodes[kinfos.size() - i]元素值）
                
                非归约动作：{action_1=func1($-1, arg2);} （在匹配住相应文法符号后进行，
                语义规则与归约动作规则一致，但不存在$0参数）
            
            其它归约约定：
                归约优先级：{reduction_priority=1} (当同时存在两个可以归约的表达式，以优先
                级高的表达式优先归约)
                
                优先归约：{reduction_first=symbol1, symbol2} （当可以归约也可以继续匹配
                时，该语句指示具体动作：当下一个符号在列表中，进行归约，否则继续匹配）
    
    读取代码文件：
        分析运行相应动作，并生成分析树（给出一个全局信息，可根据需要进一步分析），目前词法与文法错
        误的处理为直接打印错误信息并结束,可以根据需要修改错误避让规则